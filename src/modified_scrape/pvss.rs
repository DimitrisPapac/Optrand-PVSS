use ark_ec::PairingEngine;
use ark_ff::Zero;
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize, Read, SerializationError, Write};

use crate::Scalar;
use crate::modified_scrape::errors::PVSSError;


/* Struct PVSSShare models the PVSS sharing generated by the a participant when acting as dealer */

#[derive(Clone, Debug, CanonicalSerialize, CanonicalDeserialize)]
pub struct PVSSShare<E>
where
    E: PairingEngine,
    // SSIG: BatchVerifiableSignatureScheme<PublicKey = E::G1Affine, Secret = Scalar<E>>   // Double-check PublicKey (drop constraint if unnecessary)
{
    pub comms: Vec<E::G2Projective>,    	     // vector of commitments v
    pub encs: Vec<E::G1Projective>,     	     // vector of encryptions c


    // Moved to PVSSAugmentedShare
    // pub decomp_proof: Vec<DecompProof<E>>,           // decomposition proof (contains gs)

    // pub sig_of_knowledge: Option<SSIG::Signature>,
}

impl<E> PVSSShare<E>
where
    E: PairingEngine,
    // SSIG: BatchVerifiableSignatureScheme<PublicKey = E::G1Affine, Secret = Scalar<E>>   // Double-check PublicKey (drop constraint if unnecessary)
{

    // Create a new "empty" PVSSShare, where all fields are set to "zero" values.
    pub fn empty(_degree: usize, num_participants: usize) -> Self {
        PVSSShare {
	    comms: vec![E::G2Projective::zero(); num_participants],
	    encs: vec![E::G1Projective::zero(); num_participants]
        }
    }


    // Aggregation of PVSSShare instances.
    pub fn aggregate(&self, other: &Self) -> Result<Self, PVSSError<E>> {
	// Perform some basic checks
	if self.comms.len() == 0 {
	    return Err(PVSSError::EmptyEncryptionsVectorError);
	}

	if self.comms.len() != other.comms.len() {
	    return Err(PVSSError::MismatchedCommitmentsError(self.comms.len(), other.comms.len()));
	}

	if self.encs.len() != other.encs.len() {
	    return Err(PVSSError::MismatchedEncryptionsError(self.encs.len(), other.encs.len()));
	}

	if self.comms.len() != self.encs.len() {
	    return Err(PVSSError::MismatchedCommitmentsEncryptionsError(self.comms.len(), other.encs.len()));
	}

	// Aggregate PVSS shares
	let result = Self {
            comms: self
                .comms
                .iter()
                .zip(other.comms.iter())
                .map(|(c1, c2)| *c1 + *c2)
                .collect::<Vec<_>>(),
            encs: self
                .encs
                .iter()
                .zip(other.encs.iter())
                .map(|(e1, e2)| *e1 + *e2)
                .collect::<Vec<_>>(),
            // decomp_proof: [self.decomp_proof.as_slice(),
	    //	 other.decomp_proof.as_slice()].concat()
        };

	Ok(result)
    }

}


// PVSSShareSecrets models the secret parts underlying each share.
pub struct PVSSShareSecrets<E: PairingEngine> {
    pub p_0: Scalar<E>,           // secret polynomial free term s s.t.: p_i(0) = s
    pub my_secret: E::G1Affine,   // partial secret; is this one correct???
}
