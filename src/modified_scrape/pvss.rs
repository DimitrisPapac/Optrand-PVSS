use ark_ec::PairingEngine;
use ark_ff::Zero;
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize, Read, SerializationError, Write};
use crate::{Scalar, modified_scrape::errors::PVSSError};


/* Struct PVSSShare models the "core" of a PVSS sharing generated by the a participant when acting as dealer */

#[derive(Clone, Debug, CanonicalSerialize, CanonicalDeserialize)]
pub struct PVSSCore<E>
where
    E: PairingEngine,
{
    pub encs: Vec<E::G1Projective>,   // vector of encryptions c
    pub comms: Vec<E::G2Projective>,  // vector of commitments v
}

impl<E> PVSSCore<E>
where
    E: PairingEngine,
{

    // Create a new "empty" PVSS core, where all fields are set to "zero" values.
    pub fn empty(_degree: usize, num_participants: usize) -> Self {
        PVSSCore {
	    encs: vec![E::G1Projective::zero(); num_participants],
	    comms: vec![E::G2Projective::zero(); num_participants]
        }
    }


    // Aggregation of two PVSSCore instances.
    pub fn aggregate(&self, other: &Self) -> Result<Self, PVSSError<E>> {
	// Perform some basic checks
	if self.comms.len() == 0 {
	    return Err(PVSSError::EmptyEncryptionsVectorError);
	}

	if self.comms.len() != other.comms.len() {
	    return Err(PVSSError::MismatchedCommitmentsError(self.comms.len(), other.comms.len()));
	}

	if self.encs.len() != other.encs.len() {
	    return Err(PVSSError::MismatchedEncryptionsError(self.encs.len(), other.encs.len()));
	}

	if self.comms.len() != self.encs.len() {
	    return Err(PVSSError::MismatchedCommitmentsEncryptionsError(self.comms.len(), other.encs.len()));
	}

	// Aggregate PVSS cores
	let result = Self {
            comms: self
                .comms
                .iter()
                .zip(other.comms.iter())
                .map(|(c1, c2)| *c1 + *c2)
                .collect::<Vec<_>>(),
            encs: self
                .encs
                .iter()
                .zip(other.encs.iter())
                .map(|(e1, e2)| *e1 + *e2)
                .collect::<Vec<_>>(),
        };

	Ok(result)
    }

}


// PVSSShareSecrets models the secret parts underlying each share.
pub struct PVSSShareSecrets<E: PairingEngine> {
    pub p_0: Scalar<E>,           // secret polynomial free term s s.t.: p_i(0) = s
    pub my_secret: E::G1Affine,   // partial secret; is this one correct???
}
