use ark_ec::PairingEngine;
use ark_ff::Zero;
use ark_serialize::{CanonicalDeserialize, CanonicalSerialize, Read, SerializationError, Write};

use crate::signature::schnorr::{SchnorrSignature};

use super::{decomp::DecompProof};

/* Struct PVSSShare models the PVSS transcript generated by the dealer */

#[derive(Clone, Debug, CanonicalSerialize, CanonicalDeserialize)]
pub struct PVSSShare<
    E: PairingEngine,
    SSIG: BatchVerifiableSignatureScheme<PublicKey = E::G1Affine, Secret = E::Fr>   // Double-check PublicKey (drop constraint if it's unnecessary)
> {
    pub comms: Vec<E::G2Affine>,   // vector v
    pub encs: Vec<E::G1Affine>,    // vector c

    pub gs: E::G2Affine,
    // TODO: uncomment next lines
    pub proofs: Option<DecompProof<E>>,   // should this be a vector instead???
    //pub sig_of_knowledge: SSIG::Signature,   // change type according to our choice; also, is this a vector???
}

impl<E: PairingEngine> PVSSShare<E> {

    // Create a new "empty" PVSSShare, where all fields are set to "zero" values
    pub fn empty(degree: usize, num_participants: usize) -> Self {
        PVSSShare {
	    comms: vec![E::G2Affine::zero(); num_participants + 1],
	    encs: vec![E::G1Affine::zero(); num_participants + 1],
	    gs: E::G2Affine::zero(),

	    // proofs: ...,
            // sig_of_knowledge: ...,
        }
    }

    // Generate a new PVSSShare.
    pub fn create_sharing(degree: usize, num_participants: usize) -> Self {
        

    }

    /*
    // Aggregation of PVSSShare instances
    pub fn aggregate(&self, other: &Self) -> Self {
        Self {
            f_i: self
                .f_i
                .iter()
                .zip(other.f_i.iter())
                .map(|(f1, f2)| *f1 + *f2)
                .collect::<Vec<_>>(),
            u_i_2: self.u_i_2 + other.u_i_2,
            a_i: self
                .a_i
                .iter()
                .zip(other.a_i.iter())
                .map(|(a1, a2)| *a1 + *a2)
                .collect::<Vec<_>>(),
            y_i: self
                .y_i
                .iter()
                .zip(other.y_i.iter())
                .map(|(y1, y2)| *y1 + *y2)
                .collect::<Vec<_>>(),
        }
    }
    */
}

/*
// PVSSShareSecrets models the secret parts underlying each share.
pub struct PVSSShareSecrets<E: PairingEngine> {
    pub p_0: E::Fr,               // secret s s.t.: p_i(0) = s
    pub my_secret: E::G2Affine,   // actual secret; is this one correct???
}
*/